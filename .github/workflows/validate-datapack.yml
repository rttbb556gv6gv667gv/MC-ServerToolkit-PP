name: Validate Datapack

on:
  pull_request:
    paths:
      - 'new_versions/**/datapack/**'
      - '.github/workflows/validate-datapack.yml'
  push:
    branches:
      - main
    paths:
      - 'new_versions/**/datapack/**'
      - '.github/workflows/validate-datapack.yml'
  workflow_dispatch:

env:
  STRICT_MODE: false  # true = unknown commands fail, false = warnings only
  TARGET: release     # release | snapshot

jobs:
  validate:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq tree
          echo "âœ… Dependencies installed"

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # JSON SYNTAX VALIDATION
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Validate JSON Syntax
        run: |
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ” Validating JSON Files..."
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          
          error=0
          count=0
          failed_files=()

          while IFS= read -r -d $'\0' file; do
            count=$((count + 1))
            echo "  Checking: $file"
            
            if ! jq empty "$file" 2>/dev/null; then
              echo "  âŒ Invalid JSON syntax: $file"
              failed_files+=("$file")
              error=1
            fi
          done < <(find new_versions -name "*.json" -type f -print0)

          echo ""
          if [ $error -eq 0 ]; then
            echo "âœ… All $count JSON files are valid"
          else
            echo "âŒ Failed validation for ${#failed_files[@]} file(s):"
            printf '   - %s\n' "${failed_files[@]}"
            exit 1
          fi

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # FORBIDDEN METADATA CHECK
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Check Forbidden Auth Metadata
        run: |
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ”’ Checking Forbidden Metadata..."
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          
          error=0
          violations=()

          while IFS= read -r -d $'\0' file; do
            if jq -e '
              .. | objects |
              select(
                (.name? == "ely") and
                (.value? == "but why are you asking?")
              )
            ' "$file" > /dev/null 2>&1; then
              echo "  âŒ Forbidden ely.by metadata in: $file"
              violations+=("$file (ely.by)")
              error=1
            fi

            if jq -e '
              .. | objects |
              select(
                .authlib? or
                .authentication? or
                (.name? | test("auth|login|credential"; "i"))
              )
            ' "$file" > /dev/null 2>&1; then
              echo "  âš ï¸  Suspicious auth pattern in: $file"
            fi
          done < <(find new_versions -name "*.json" -type f -print0)

          echo ""
          if [ $error -eq 0 ]; then
            echo "âœ… No forbidden metadata found"
          else
            echo "âŒ Found ${#violations[@]} violation(s)"
            exit 1
          fi

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # PACK.MCMETA VALIDATION
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Validate pack.mcmeta Files
        run: |
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ“¦ Validating pack.mcmeta Files..."
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          
          found=0
          error=0
          warnings=0

          # Valid pack format values
          VALID_FORMATS=(81 88 94)
          INVALID_THRESHOLD=80

          # Pack format cache
          mkdir -p /tmp/pack_formats

          while IFS= read -r -d $'\0' file; do
            found=1
            
            # Find datapack root (directory containing pack.mcmeta)
            datapack_root=$(dirname "$file")
            datapack_id=$(echo "$datapack_root" | md5sum | cut -d' ' -f1)
            
            echo "  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo "  ğŸ“¦ File: $file"
            echo "  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

            # Required: pack.pack_format
            if ! jq -e '.pack.pack_format' "$file" > /dev/null 2>&1; then
              echo "    âŒ Missing pack.pack_format"
              error=1
              continue
            fi

            pack_format=$(jq -r '.pack.pack_format' "$file")
            echo "    â„¹ï¸  Pack format: $pack_format"
            
            # Cache pack format
            echo "$pack_format:$datapack_root" > "/tmp/pack_formats/${datapack_id}.txt"
            
            # Pack format validation
            is_valid=0
            for valid_format in "${VALID_FORMATS[@]}"; do
              if [ "$pack_format" -eq "$valid_format" ] 2>/dev/null; then
                is_valid=1
                break
              fi
            done

            if [ $is_valid -eq 1 ]; then
              case $pack_format in
                81)
                  echo "    âœ… Pack format 81 (MC 1.20.2 - 1.20.4)"
                  ;;
                88)
                  echo "    âœ… Pack format 88 (MC 1.21.2 - 1.21.3)"
                  ;;
                94)
                  echo "    âœ… Pack format 94 (MC 1.21.4+)"
                  ;;
              esac
            elif [ "$pack_format" -le "$INVALID_THRESHOLD" ] 2>/dev/null; then
              echo "    âŒ INVALID: pack_format $pack_format is â‰¤80"
              echo "       â†’ Must be 81, 88, or 94"
              error=1
            else
              echo "    âš ï¸  Unknown pack_format: $pack_format"
              echo "       â†’ Expected: 81, 88, or 94"
              warnings=$((warnings + 1))
            fi

            # Description check
            if ! jq -e '.pack.description' "$file" > /dev/null 2>&1; then
              echo "    âš ï¸  Missing pack.description"
              warnings=$((warnings + 1))
            else
              desc_type=$(jq -r '.pack.description | type' "$file")
              if [ "$desc_type" = "string" ]; then
                desc=$(jq -r '.pack.description' "$file" | head -c 60)
                echo "    âœ“ Description: $desc"
              elif [ "$desc_type" = "object" ]; then
                if jq -e '.pack.description.text' "$file" > /dev/null 2>&1; then
                  desc=$(jq -r '.pack.description.text' "$file" | head -c 60)
                  echo "    âœ“ Description (text component): $desc"
                fi
              fi
            fi

            # supported_formats
            if jq -e '.pack.supported_formats' "$file" > /dev/null 2>&1; then
              sf_type=$(jq -r '.pack.supported_formats | type' "$file")
              if [ "$sf_type" = "object" ]; then
                min_inc=$(jq -r '.pack.supported_formats.min_inclusive' "$file")
                max_inc=$(jq -r '.pack.supported_formats.max_inclusive' "$file")
                echo "    âœ“ Supported formats: $min_inc - $max_inc"
              fi
            fi

            # Invalid fields (NOT used by Minecraft)
            if jq -e '.pack.min_format' "$file" > /dev/null 2>&1; then
              echo "    âš ï¸  'pack.min_format' is NOT a valid Minecraft field"
              echo "       â†’ Use 'pack.supported_formats.min_inclusive' instead"
              warnings=$((warnings + 1))
            fi
            
            if jq -e '.pack.max_format' "$file" > /dev/null 2>&1; then
              echo "    âš ï¸  'pack.max_format' is NOT a valid Minecraft field"
              echo "       â†’ Use 'pack.supported_formats.max_inclusive' instead"
              warnings=$((warnings + 1))
            fi

            if jq -e '.metadata' "$file" > /dev/null 2>&1; then
              echo "    âš ï¸  'metadata' is NOT a valid Minecraft field"
              echo "       â†’ This section will be ignored by the game"
              warnings=$((warnings + 1))
            fi

            if jq -e '.language' "$file" > /dev/null 2>&1; then
              echo "    âš ï¸  'language' is only valid in RESOURCE packs, not datapacks"
              echo "       â†’ This section will be ignored by the game"
              warnings=$((warnings + 1))
            fi

            # Filter (valid)
            if jq -e '.filter' "$file" > /dev/null 2>&1; then
              block_count=$(jq '.filter.block | length' "$file" 2>/dev/null || echo 0)
              echo "    âœ“ Filter with $block_count block pattern(s)"
            fi

            # Overlays (valid)
            if jq -e '.overlays' "$file" > /dev/null 2>&1; then
              overlay_count=$(jq '.overlays.entries | length' "$file")
              echo "    âœ“ Has $overlay_count overlay(s)"
            fi

            # Features (valid)
            if jq -e '.features' "$file" > /dev/null 2>&1; then
              echo "    âœ“ Has feature flags"
            fi

            echo ""
          done < <(find new_versions -path "*/datapack/pack.mcmeta" -type f -print0)

          if [ $found -eq 0 ]; then
            echo "âŒ No pack.mcmeta files found"
            exit 1
          fi

          if [ $error -eq 0 ]; then
            echo "âœ… All pack.mcmeta files are valid"
            [ $warnings -gt 0 ] && echo "âš ï¸  $warnings warning(s) - non-standard fields detected"
          else
            echo "âŒ pack.mcmeta validation failed"
            exit 1
          fi

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # DATAPACK STRUCTURE
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Validate Datapack Structure
        run: |
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ“ Validating Datapack Structure..."
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          
          error=0
          datapack_count=0

          while IFS= read -r -d $'\0' file; do
            dir=$(dirname "$file")
            datapack_count=$((datapack_count + 1))
            echo "  Datapack #$datapack_count: $dir"

            if [ ! -d "$dir/data" ]; then
              echo "    âŒ Missing data/ directory"
              error=1
            else
              echo "    âœ… data/ directory exists"
              
              namespace_count=$(find "$dir/data" -mindepth 1 -maxdepth 1 -type d 2>/dev/null | wc -l)
              echo "    â„¹ï¸  Found $namespace_count namespace(s)"

              if [ $namespace_count -gt 0 ]; then
                while IFS= read -r namespace; do
                  ns_name=$(basename "$namespace")
                  echo "      â†’ $ns_name"
                  
                  [ -d "$namespace/function" ] && echo "        âœ“ function/"
                  [ -d "$namespace/tags" ] && echo "        âœ“ tags/"
                  [ -d "$namespace/advancement" ] && echo "        âœ“ advancement/"
                  [ -d "$namespace/loot_table" ] && echo "        âœ“ loot_table/"
                  [ -d "$namespace/recipe" ] && echo "        âœ“ recipe/"
                  
                done < <(find "$dir/data" -mindepth 1 -maxdepth 1 -type d 2>/dev/null)
              fi
            fi

            echo ""
          done < <(find new_versions -path "*/datapack/pack.mcmeta" -type f -print0)

          if [ $error -eq 0 ]; then
            echo "âœ… Datapack structure validation passed"
          else
            echo "âŒ Datapack structure validation failed"
            exit 1
          fi

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # MCFUNCTION DETECTION
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Detect Function Files
        run: |
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ” Detecting .mcfunction Files..."
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          
          count=0
          while IFS= read -r -d $'\0' file; do
            count=$((count + 1))
            echo "  Found: $file"
          done < <(find new_versions -path "*/datapack/data/*/function/*.mcfunction" -type f -print0)
          
          echo ""
          echo "ğŸ“Š Total: $count .mcfunction file(s)"
          
          if [ $count -eq 0 ]; then
            echo "âš ï¸  No .mcfunction files detected"
          else
            echo "âœ… .mcfunction files detected"
          fi

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # MCFUNCTION CONTENT VALIDATION
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Validate Function Files Content
        run: |
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "âš™ï¸  Validating Function Content..."
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          
          error=0
          warnings=0
          total_count=0
          total_lines=0
          total_commands=0

          # Command compatibility matrix
          declare -A command_min_format
          
          # Basic commands
          command_min_format["say"]=1
          command_min_format["tell"]=1
          command_min_format["tellraw"]=1
          command_min_format["msg"]=1
          command_min_format["title"]=1
          command_min_format["give"]=1
          command_min_format["clear"]=1
          command_min_format["summon"]=1
          command_min_format["kill"]=1
          command_min_format["tp"]=1
          command_min_format["teleport"]=1
          command_min_format["setblock"]=1
          command_min_format["fill"]=1
          command_min_format["clone"]=1
          command_min_format["execute"]=1
          command_min_format["particle"]=1
          command_min_format["playsound"]=1
          command_min_format["effect"]=1
          command_min_format["enchant"]=1
          command_min_format["scoreboard"]=1
          command_min_format["team"]=1
          command_min_format["tag"]=1
          command_min_format["data"]=1
          command_min_format["gamemode"]=1
          command_min_format["difficulty"]=1
          command_min_format["weather"]=1
          command_min_format["time"]=1
          command_min_format["gamerule"]=1
          command_min_format["worldborder"]=1
          command_min_format["forceload"]=1
          command_min_format["function"]=1
          command_min_format["schedule"]=1
          command_min_format["datapack"]=1
          command_min_format["reload"]=1
          command_min_format["advancement"]=1
          command_min_format["recipe"]=1
          command_min_format["loot"]=1
          command_min_format["bossbar"]=1
          
          # New commands
          command_min_format["item"]=81
          command_min_format["damage"]=81
          command_min_format["ride"]=81
          command_min_format["return"]=81
          command_min_format["tick"]=81
          command_min_format["random"]=81
          
          # Special/mod commands
          command_min_format["dialog"]=1
          
          # Deprecated
          declare -A deprecated_commands
          deprecated_commands["replaceitem"]="Use /item replace instead"

          while IFS= read -r -d $'\0' file; do
            total_count=$((total_count + 1))
            
            # Find pack format correctly
            current_pack_format=0
            file_dir="$file"
            
            # Find datapack/ folder
            while [ "$file_dir" != "/" ] && [ "$file_dir" != "." ]; do
              if [ -f "$file_dir/pack.mcmeta" ]; then
                datapack_id=$(echo "$file_dir" | md5sum | cut -d' ' -f1)
                if [ -f "/tmp/pack_formats/${datapack_id}.txt" ]; then
                  current_pack_format=$(cut -d':' -f1 "/tmp/pack_formats/${datapack_id}.txt")
                fi
                break
              fi
              file_dir=$(dirname "$file_dir")
            done

            relative_path=$(echo "$file" | sed "s|^$(pwd)/||")
            echo ""
            echo "  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo "  ğŸ“„ $relative_path"
            echo "  ğŸ“¦ Pack format: $current_pack_format"
            echo "  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

            line_count=$(wc -l < "$file")
            total_lines=$((total_lines + line_count))

            if [ $line_count -eq 0 ]; then
              echo "    âš ï¸  Empty file"
              warnings=$((warnings + 1))
              continue
            fi

            # CRLF check
            if grep -q $'\r' "$file"; then
              echo "    âŒ Windows line endings (CRLF) - use LF only"
              error=1
            fi

            # Tab check
            if grep -q $'\t' "$file"; then
              echo "    âš ï¸  Contains tabs - use spaces"
              warnings=$((warnings + 1))
            fi

            # Line by line analysis
            line_num=0
            file_commands=0
            
            while IFS= read -r line; do
              line_num=$((line_num + 1))
              
              # Empty and comment check
              [[ "$line" =~ ^[[:space:]]*$ ]] && continue
              [[ "$line" =~ ^[[:space:]]*# ]] && continue

              file_commands=$((file_commands + 1))
              total_commands=$((total_commands + 1))

              # Clean line
              clean_line=$(echo "$line" | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//')
              [[ "$clean_line" =~ ^/ ]] && clean_line="${clean_line:1}"
              
              # Command name
              cmd=$(echo "$clean_line" | cut -d' ' -f1)

              # Deprecated check
              if [ -n "${deprecated_commands[$cmd]}" ]; then
                echo "    âŒ Line $line_num: Deprecated command '/$cmd'"
                echo "       â†’ ${deprecated_commands[$cmd]}"
                error=1
                continue
              fi

              # Command compatibility
              if [ -n "${command_min_format[$cmd]}" ]; then
                required_format="${command_min_format[$cmd]}"
                
                if [ "$current_pack_format" -gt 0 ] && [ "$current_pack_format" -lt "$required_format" ]; then
                  echo "    âŒ Line $line_num: '/$cmd' requires pack_format $required_format+ (current: $current_pack_format)"
                  error=1
                fi
              else
                if [[ ! "$cmd" =~ ^(minecraft:|#) ]]; then
                  if [ "$STRICT_MODE" = "true" ]; then
                    echo "    âŒ Line $line_num: Unknown command '/$cmd' (STRICT_MODE enabled)"
                    error=1
                  else
                    echo "    â„¹ï¸  Line $line_num: Custom command '/$cmd'"
                  fi
                fi
              fi

              # Execute subcommand
              if [[ "$clean_line" =~ ^execute ]]; then
                if [[ "$clean_line" =~ (if|unless)[[:space:]]+biome ]] && [ "$current_pack_format" -gt 0 ] && [ "$current_pack_format" -lt 81 ]; then
                  echo "    âŒ Line $line_num: 'execute if/unless biome' requires pack_format 81+"
                  error=1
                fi
                
                if [[ "$clean_line" =~ (if|unless)[[:space:]]+dimension ]] && [ "$current_pack_format" -gt 0 ] && [ "$current_pack_format" -lt 81 ]; then
                  echo "    âŒ Line $line_num: 'execute if/unless dimension' requires pack_format 81+"
                  error=1
                fi
                
                if [[ "$clean_line" =~ execute[[:space:]]+on[[:space:]] ]] && [ "$current_pack_format" -gt 0 ] && [ "$current_pack_format" -lt 81 ]; then
                  echo "    âŒ Line $line_num: 'execute on' requires pack_format 81+"
                  error=1
                fi
              fi

              # Suspicious pattern
              if [[ "$clean_line" =~ execute.*run.*execute.*run.*execute ]]; then
                echo "    âš ï¸  Line $line_num: Very deep execute chain"
                warnings=$((warnings + 1))
              fi

              # Path traversal
              if [[ "$clean_line" =~ \.\. ]]; then
                echo "    âŒ Line $line_num: Path traversal (..) not allowed"
                error=1
              fi

            done < "$file"

            echo "    âœ“ $file_commands command(s) in $line_count line(s)"

          done < <(find new_versions -path "*/datapack/data/*/function/*.mcfunction" -type f -print0)

          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ“Š Summary:"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "  Total files:     $total_count"
          echo "  Total lines:     $total_lines"
          echo "  Total commands:  $total_commands"
          [ $total_count -gt 0 ] && echo "  Avg lines/file:  $((total_lines / total_count))"

          if [ $error -eq 0 ]; then
            echo ""
            echo "âœ… Function validation passed"
            [ $warnings -gt 0 ] && echo "âš ï¸  $warnings warning(s)"
          else
            echo ""
            echo "âŒ Function validation failed"
            exit 1
          fi

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # MACRO VALIDATION
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Validate Macro System
        run: |
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ”§ Validating Macro System..."
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          
          error=0
          files_with_macros=0
          total_vars=0

          while IFS= read -r -d $'\0' file; do
            
            # Find pack format
            current_pack_format=0
            file_dir="$file"
            while [ "$file_dir" != "/" ] && [ "$file_dir" != "." ]; do
              if [ -f "$file_dir/pack.mcmeta" ]; then
                datapack_id=$(echo "$file_dir" | md5sum | cut -d' ' -f1)
                if [ -f "/tmp/pack_formats/${datapack_id}.txt" ]; then
                  current_pack_format=$(cut -d':' -f1 "/tmp/pack_formats/${datapack_id}.txt")
                fi
                break
              fi
              file_dir=$(dirname "$file_dir")
            done

            relative_path=$(echo "$file" | sed "s|^$(pwd)/||")
            
            # Only find real macro syntax: $(var)
            macro_vars=$(grep -oP '\$\(\K[a-zA-Z0-9_]+(?=\))' "$file" 2>/dev/null | sort -u)
            macro_count=$(echo "$macro_vars" | grep -c '.' || echo 0)
            
            # $ without $(var) - could be JSONraw, regex, etc.
            dollar_without_macro=$(grep -oP '\$(?!\()' "$file" 2>/dev/null | wc -l || echo 0)
            
            if [ $macro_count -gt 0 ]; then
              # Real macro found
              files_with_macros=$((files_with_macros + 1))
              total_vars=$((total_vars + macro_count))
              
              echo "  âœ… $relative_path"
              echo "     â†’ Pack format: $current_pack_format"
              echo "     â†’ Macro variables ($macro_count): $(echo $macro_vars | tr '\n' ', ' | sed 's/, $//')"
              
              # Pack format check
              if [ "$current_pack_format" -gt 0 ] && [ "$current_pack_format" -lt 81 ]; then
                echo "     âŒ ERROR: Macros require pack_format 81+"
                error=1
              fi
              
            elif [ $dollar_without_macro -gt 0 ]; then
              # $ but no $(var)
              echo "  â„¹ï¸  $relative_path"
              echo "     â†’ Contains $ character (likely in JSON/NBT, not macros)"
              echo "     â†’ If you intend to use macros, use \$(variable_name) syntax"
            fi

          done < <(find new_versions -path "*/datapack/data/*/function/*.mcfunction" -type f -print0)

          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ“Š Macro Summary:"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "  Files with macros:     $files_with_macros"
          echo "  Total macro variables: $total_vars"
          
          if [ $files_with_macros -gt 0 ]; then
            echo ""
            echo "  â„¹ï¸  Macro Requirements:"
            echo "     â€¢ Pack format: 81+ (MC 1.20.2+)"
            echo "     â€¢ Syntax: \$(variable_name)"
            echo "     â€¢ Example: function ns:path {var: value}"
          fi

          if [ $error -eq 0 ]; then
            echo ""
            if [ $files_with_macros -eq 0 ]; then
              echo "â„¹ï¸  No macro usage detected"
            else
              echo "âœ… Macro validation passed"
            fi
          else
            echo ""
            echo "âŒ Macro validation failed"
            exit 1
          fi

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # NAMESPACE VALIDATION
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Validate Namespaces
        run: |
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ·ï¸  Validating Namespaces..."
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          
          error=0
          count=0
          
          while IFS= read -r -d $'\0' namespace; do
            count=$((count + 1))
            ns_name=$(basename "$namespace")
            echo "  [$count] $ns_name"

            if ! [[ "$ns_name" =~ ^[a-z0-9_.-]+$ ]]; then
              echo "      âŒ Invalid name (use: a-z, 0-9, _, ., -)"
              error=1
            else
              echo "      âœ“ Valid"
            fi

            if [ "$ns_name" = "minecraft" ]; then
              echo "      âš ï¸  Reserved namespace"
            fi

            if [ ${#ns_name} -gt 255 ]; then
              echo "      âŒ Too long (max: 255)"
              error=1
            fi

          done < <(find new_versions -path "*/datapack/data/*" -mindepth 1 -maxdepth 1 -type d -print0)

          echo ""
          echo "  Total: $count namespace(s)"
          
          if [ $error -eq 0 ]; then
            echo "âœ… Namespace validation passed"
          else
            echo "âŒ Namespace validation failed"
            exit 1
          fi

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # FINAL SUMMARY
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Validation Summary
        if: always()
        run: |
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ“‹ VALIDATION SUMMARY"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo ""
          echo "  Mode:  $STRICT_MODE (STRICT_MODE)"
          echo "  Target: $TARGET"
          echo ""
          echo "  âœ… Valid Pack Formats:   81, 88, 94"
          echo "  âŒ Invalid Pack Formats: â‰¤80"
          echo ""
          echo "  ğŸ“¦ pack.mcmeta:   $(find new_versions -path "*/datapack/pack.mcmeta" -type f 2>/dev/null | wc -l)"
          echo "  ğŸ“„ JSON Files:    $(find new_versions -name '*.json' -type f 2>/dev/null | wc -l)"
          echo "  âš™ï¸  Functions:     $(find new_versions -name '*.mcfunction' -type f 2>/dev/null | wc -l)"
          echo "  ğŸ·ï¸  Namespaces:    $(find new_versions -path '*/datapack/data/*' -mindepth 1 -maxdepth 1 -type d 2>/dev/null | wc -l)"
          echo "  ğŸ”§ With Macros:   $(find new_versions -name '*.mcfunction' -type f -exec grep -l '\$(' {} \; 2>/dev/null | wc -l)"
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          
          if [ "${{ job.status }}" == "success" ]; then
            echo "âœ… ALL VALIDATIONS PASSED"
            echo ""
            echo "Datapack is production-ready! ğŸš€"
          else
            echo "âŒ VALIDATION FAILED"
            echo ""
            echo "Common issues:"
            echo "  â€¢ pack_format â‰¤80 (use 81, 88, or 94)"
            echo "  â€¢ Non-standard pack.mcmeta fields"
            echo "  â€¢ Commands incompatible with pack_format"
            echo "  â€¢ Invalid macro syntax"
          fi
          
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # UPLOAD ARTIFACTS
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Upload Validation Logs
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: validation-logs
          path: |
            new_versions/**/datapack/**/*.json
            new_versions/**/datapack/**/*.mcfunction
          retention-days: 7
